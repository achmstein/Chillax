name: Deploy to Server

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository_owner }}/chillax

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' }}
    environment: ${{ github.event.inputs.environment || 'production' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'

      - name: Install Aspire CLI
        run: dotnet tool install --global aspire.cli --prerelease

      - name: Generate Docker Compose artifacts
        env:
          Parameters__postgres_password: postgres
          Parameters__eventbus_password: guest
          Parameters__keycloak_password: admin
        run: |
          cd src/Chillax.AppHost
          aspire publish -o ../../deploy-artifacts

      - name: Prepare deployment artifacts
        run: |
          cp src/Chillax.AppHost/KeycloakConfiguration/chillax-realm.json deploy-artifacts/chillax-realm.json
          sed -i 's|source: ".*chillax-realm.json"|source: "./chillax-realm.json"|g' deploy-artifacts/docker-compose.yaml
          sed -i 's|target: "/opt/keycloak/data/import"|target: "/opt/keycloak/data/import/chillax-realm.json"|g' deploy-artifacts/docker-compose.yaml

          # Fill empty .env values (aspire publish generates empty placeholders)
          sed -i 's/^POSTGRES_PASSWORD=$/POSTGRES_PASSWORD=postgres/' deploy-artifacts/.env
          sed -i 's/^EVENTBUS_PASSWORD=$/EVENTBUS_PASSWORD=guest/' deploy-artifacts/.env
          sed -i 's/^KEYCLOAK_PASSWORD=$/KEYCLOAK_PASSWORD=admin/' deploy-artifacts/.env

          # Fill port values for service discovery
          sed -i 's/^CATALOG_API_PORT=$/CATALOG_API_PORT=8080/' deploy-artifacts/.env
          sed -i 's/^ORDERING_API_PORT=$/ORDERING_API_PORT=8080/' deploy-artifacts/.env
          sed -i 's/^ROOMS_API_PORT=$/ROOMS_API_PORT=8080/' deploy-artifacts/.env
          sed -i 's/^IDENTITY_API_PORT=$/IDENTITY_API_PORT=8080/' deploy-artifacts/.env
          sed -i 's/^LOYALTY_API_PORT=$/LOYALTY_API_PORT=8080/' deploy-artifacts/.env
          sed -i 's/^NOTIFICATION_API_PORT=$/NOTIFICATION_API_PORT=8080/' deploy-artifacts/.env
          sed -i 's/^ACCOUNTS_API_PORT=$/ACCOUNTS_API_PORT=8080/' deploy-artifacts/.env

          # Add external identity URL for JWT issuer validation in production
          # Tokens are issued via the public URL, so backend services need to accept it
          EXTERNAL_ISSUER="http://${{ secrets.SERVER_HOST }}/realms/chillax"
          sed -i "/Identity__Url/a\\      Identity__ExternalUrl: \"${EXTERNAL_ISSUER}\"" deploy-artifacts/docker-compose.yaml

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: deploy-artifacts
          path: deploy-artifacts/

      - name: Copy deployment files to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          source: "deploy-artifacts/*"
          target: ${{ secrets.DEPLOY_PATH }}
          strip_components: 1

      - name: Deploy to server
        uses: appleboy/ssh-action@v1
        env:
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
          GHCR_USER: ${{ github.actor }}
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          envs: GHCR_TOKEN,GHCR_USER
          script: |
            cd ${{ secrets.DEPLOY_PATH }}

            # Login to GHCR
            echo "$GHCR_TOKEN" | docker login ghcr.io -u "$GHCR_USER" --password-stdin

            # Pull pre-built images and build any Aspire-generated services (e.g. mobile-bff)
            docker compose pull --ignore-buildable
            docker compose up -d --build --remove-orphans

            # Cleanup old images
            docker image prune -f

            # Show running containers
            docker compose ps

  notify:
    runs-on: ubuntu-latest
    needs: deploy
    if: always()
    steps:
      - name: Notify deployment status
        run: |
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "Deployment successful!"
          else
            echo "Deployment failed!"
            exit 1
          fi
